### 1 Sentinel的熔断状态 

```
OPEN	    表示熔断开启，拒绝所有请求
HALF_OPEN	探测恢复状态，如果接下来的一个请求顺利通过则表示结束熔断，否则继续熔断
CLOSE	    表示熔断关闭，请求顺利通过
```

### 2 什么是熔断降级 

```
熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时， 会进行服务降级，进而熔断
该节点微服务的调用，快速返回“错误”的响应信息。
服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端 可以自己准备一个本地的
fallback回调，返回一个缺省值。
```

### 3 SpringBoot 如何实现自动配置  

```
@SpringBootApplication注解中包含@EnableAutoConfiguration注解。

@EnableAutConfiguration注解中使用了
@Import({AutoConfigurationImportSelector.class})注解。
AutoConfigurationImportSelector类中读取，META-INF/spring.factories配置文件中的所有自动配置类， 并对其进行
加载。

自动配置类是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类, 读取在全局配置文件中配置
的属性值。
```

### 4 SpringBoot的核心注解？它主要由哪几个注解组成的? 

```
@SpringBootApplication是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：

@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。
@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项。
@ComponentScan: Spring组件扫描。
```

### 5 HashMap的数据结构

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675475049559.png" alt="1675475049559" style="zoom:50%;" />

```
HashMap采用数组 + 链表 + 红黑树的方式保存数据。HashMap在查找数据时,根据HashMap的Hash值可以快速定位到数组的具
体下标。但是在找到数组下标后需要对链表进行顺序遍历直到找到需要的数据。为了减少链表遍历的开销,Java8对HashMap进行
了优化,将数据结构优化为数组+链表+红黑树。如果链表长度大于阈值(8) 数组长度超过64,则进行树化(将链表转为红黑树)会
将此链表转为红黑树结构。
```

### 6 HashMap添加元素的过程 

```
1 首先判断数组是否为空如果数组为空则需要对数组进行扩容。

2 如果数组不为空,则通过数组长度-1与新增元素的kye的hash值进行位运算，得到数组的下标,通过下标获
得该下标对应的数组元素。

3 判断获得的数组元素是否为空, 如果为空则使用新增的键-值创建节点,将节点放在数组此位置上。

4 如果数组的元素不为空,则判断新增的元素hash值和key值,是否与数组中第一个元素的hash值和key值相
等,如果相等则用新的值替换老的值。

5 如果不相等,则判断数组元素是否是红黑树,如果是红黑树,则向红黑树中添加元素。

6 如果不是红黑树,则对链表进行遍历,并且统计链表长度，如果链表中不包含要插入的键值对节点时,则该节
点放在链表的最后。如果链表长度大于阈值(8) 数组长度超过64,则进行树化(将链表转为红黑树)。如果要插
入的键值对存在,则用新的值替换老的值。

7 如果map中元素的个数大于扩容的阈值(数组长度*负载因子),则需要对数组进行扩容。
```

### 7 HashMap HashTable的区别? 

```
HashMap和Hashtable都实现了Map接口，HashMap几乎可以等价于Hashtable
除了HashMap不是线程安全的，HashTable是线程安全的。
HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行
```

### 8  hash的概念是什么?如何避免哈希冲突? 

```
hash，是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。
如何避免哈希冲突?
(1)链地址法
将所有哈希地址相同的元素构成一个单链表。链地址法适用于经常进行插入和删除的情况。
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675475211791.png" alt="1675475211791" style="zoom: 67%;" />

### 9  线程的创建方式有哪些?

```
创建线程只有一种方式就是构造Thread类,而实现线程的执行单元有两种方式。
方式一:实现Runnable接口的run方法,并把Runnable实例传递给Thread类。 
方式二:重写Thread类的run方法。
```

### 10 线程的状态有哪些? 

```
NEW:当创建一个线程对象，还没有调用start()方法。
RUNNABLE：调用了start()方法，不管线程是否被CPU执行，都处于RUNNABLE。
BLOCKED: 线程等待获取对象的监视器锁时,处于BLOCKED状态时，线程无法被中断。
WAITING：线程处于无限等待状态，除非被其它线程唤醒或者接收到中断信号。
TIMED_WAITING：定时等待，线程等待指定时间后会恢复到RUNNABLE状态。可以提前被唤醒或者中断。
TERMINATED：线程执行完毕。
```

### 11 线程池中构造方法的参数有哪些?有什么作用? 

```
corePoolSize指的是核心线程数:线程池在完成初始化后,默认情况下,线程池中并没有任何线程,线程池会等待有任务到来时,
再创建新线程去执行任务。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会
创建一个新线程来处理这个任务。

当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列中。如果队列也已满，则会去创
建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由
maxPoolSize指定。

一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指
定时间由keepAliveTime来设定。

工作队列有四种:
直接交接队列: 这种队列中不会保存任务。
无界队列: 这种队列中没有指定容量上限。
有界队列: 这种队列中有一个指定的容量。
延迟队列: 任务定时周期的延迟执行的队列。
```

![1675475463301](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675475463301.png)

### 12  如何中断一个线程? 

```
interrupt通知线程要中断,不是强制。线程在执行完以后,才中断。
```

### 13 锁的分类

![1675475605772](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675475605772.png)

```
乐观锁:
乐观锁总是认为不存在并发问题，每次去取数据的时候，总认为不会有其他线程对数据进行修改，因此不会上锁。但是在更新
时会判断其他线程在这之前有没有对数据进行修改，一般会使用“数据版本机制”或“CAS操作”来实现。

悲观锁:
悲观锁认为对于同一个数据的并发操作，一定会发生修改的，哪怕没有修改，也会认为修改。因此对于同一份数据的并发操
作，悲观锁采取加锁的形式。悲观的认为，不加锁并发操作一定会出问题。在对任意记录进行修改前，先尝试为该记录加上排
他锁。如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。如果成功加锁，那么就可以对记录做
修改，事务完成后就会解锁了。期间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

自旋锁:
如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形
象地比喻为“自旋”，就像是线程在“自我旋转”。相反，非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者
进行其他的处理逻辑，例如去排队、陷入阻塞等。

公平锁 VS 非公平锁:
公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程
会优先拿到这把锁，有先来先得的意思。而非公平锁就不那么“完美”了，发生插队现象。

可重入锁 VS 非可重入锁:
可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。同理，不可重入锁指的是虽然线
程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。对于可重入锁而言，最典型的就
是 ReentrantLock 了，正如它的名字一样，reentrant 的意思就是可重入，它也是 Lock 接口最主要的一个实现类。

独占锁 VS 共享锁:
共享锁指的是我们同一把锁可以被多个线程同时获得，而独占锁指的就是，这把锁只能同时被一个线程获得。我们的读写锁，
就最好地诠释了共享锁和独占锁的理念。读写锁中的读锁，是共享锁，而写锁是独占锁。读锁可以被同时读，可以同时被多个
线程持有，而写锁最多只能同时被一个线程持有。
```

### 14 sleep()方法和wait()方法有什么区别? 

```
sleep方法可以让线程进入Waiting状态,不占用CPU资源,但是不释放锁,直到规定时间后再执行。休眠期间如果被中断,会抛出
异常并清除中断状态。sleep方法是线程中的方法。
wait方法可以让线程会进入阻塞阶段。wait方法会释放锁。wait方法是Object类中的方法。
```

### 15 关闭线程池的方法有哪些?他们有什么区别?

```
shutdown方法: 停止线程池,会将线程池中已经存在的任务执行完毕以后,在停止线程池。如果执行了shutdown方法以后,在向
线程池中添加任务,线程池会抛出拒绝的异常。
shutdownNow: 中断线程池中正在运行的任务,将任务队列中的任务返回。
```

### 16 volatile关键字的作用是什么?

```
可见性: 读一个 volatile 变量之前，需要先使相应的本地缓存失效,这样就必须到主内存读取最新值，写一个volatile 属性
会立即刷入到主内存。

禁止指令重排序优化:解决单例双重锁乱序问题
```

### 17 ThreadLoacl的作用有哪些? 

```
场景1 每个线程需要一个独享的对象(通常是工具类,典型需要使用的类有SimpleDateFormat和Random)
场景2 每个线程内需要保存全局变量,可以让不同方法直接使用,避免参数传递的麻烦
```

### 18 线程中run方法和start方法的作用? 

```
start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当调用
run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。
```

### 19 线程池的拒绝策略有哪些? 

```
AbortPolicy: 直接抛出异常
DiscardPolicy: 直接丢弃
DiscardOldestPolicy: 丢弃最老的任务
CallerRunsPolicy: 提交任务的线程去执行该任务
```

### 20 CAS的原理?CAS的缺点?

原理

```
compare and swap
CAS有是三个操作数: 内存值V    预期值A   要修改的值B, 并且当预期值A与内存值V相同时,才向内存值修改为B,否则什么都
不做。最后返回现在的值。CAS最终利用CPU的特殊指令, 一个指令可以做多个事情。
```

缺点

```
(1) ABA问题
   假设原来a的值是5,线程3想将a的值修改为10,在线程3执行的过程中,还没有来及更新a的值。线程1先
将a的值修改为了7, 线程2将a的值修改为了5。 线程C此时在去修改a的值, 发现现在a的值是5。线程C就可
以修改a的值,将值改为10。 但是此时能够修改数据应该是不合理的,因为线程C在修改a的值之前,已经有线程
修改了a的值。可以添加version版本号的方式解决该问题。 

(2) 自旋时间过长
```

### 21 CyclicBarrier和CountDownLatch的区别?

```
作用不同: CyclicBarrier要等固定数量的线程都到达了栅栏位置才能继续执行，而CountDownLatch需等待数字到0线程继续
执行。

可重用性不同:CountDownLatch在倒数到0并触发门闩打开后，就不能再次使用了，除非新建新的实例;
而CyclicBarrierrier可以重复使用。
```

### 22 ReentrantLock与synchronzied的区别？

```
(1)synchronized 可用来修饰普通方法、静态方法和代码块，而ReentrantLock 只能用在代码块上。

(2)synchronized 会自动加锁和释放锁，当进入 synchronized 修饰的代码块之后会自动加锁，当离开 synchronized的代
码段之后会自动释。而 ReentrantLock 需要手动加锁和释放锁

(3)synchronized 属于非公平锁，而 ReentrantLock 既可以是公平锁也可以是非公平锁。

(4)响应中断不同：ReentrantLock 可以响应中断，解决死锁的问题，而 synchronized 不能响应中断。
```

### 23 HashSet新增元素的过程？

```
(1)  HashSet 在新增数据的时候,先判断内部的数组是否为空,如果数组为空,则初始化数组。
(2)  如果数组不为空,获得向HashSet中添加的元素的哈希码(元素的hashcode方法获得哈希码) 在经过一
系列的算法,计算出该元素存储在HashSet数组中的位置。
(3) 在HashSet的数组中查找该位置上是否有元素,如果该位置上没有元素,则此元素就可以放到该位置上。
(4) 如果该位置有元素,则比较新增元素与该位置上的元素的哈希码,如果哈希码不同,新增的元素放在该位置
的链表的末尾。
(5) 如果元素的哈希码相同,新增的元素调用equals方法和原来的元素进行比较,如果equals方法的返回值
是false,表示两个元素不相等,新增的元素放在该位置的链表的末尾。
(6)如果equals方法的返回值相同,则新增失败。
```

### 24 mybatis中#{}和${}的区别？

```
${} 类似于通过替换后生成sql语句，类似于JDBC中的Statement,不能防止sql语句注入。
#{} 可以绑定变量，可以防止sql注入攻击,类似于JDBC中的PreparedStatement。
```

### 25 Ribbon 负载均衡的策略有哪些？

```
RoundRobinRule: 轮询策略。 按server顺序返回server,在返回之前会判断服务是可用。如果不可用 则尝试返回下一个服
务实例,如果超过10次,返回的服务都不可用,则返回一个空的server。

RandomRule: 随机策略, 随机返回一个server。如果随机到的server为null或者不可用的话,会循环不停的选取。

RetryRule: 默认继承RoundRobinRule，RetryRule会在每次选取之后,判断server是否可用,如果不可用则采用轮询的方
式,返回下一个服务,在去判断服务是否可用,与RoundRobinRule不同的是,RoundRobinRule是超过10次不可用,则返回一个空
的server。而RetryRule是500ms内不停的选取判断。

BestAvailableRule: 最小连接数策略。遍历serverList,选取出可用的且连接数最小的一个server。

AvailabilityFilterRule:可用过滤策略。扩展了轮询策略,会先通过轮询选取一个server,再去判断server是否可用,当前
连接数是否超限,都成功再返回。
```

### 26 SpringBoo项目如何实现异常处理？

```
1 创建异常处理类,在该类上添加@RestControllerAdvice注解

2 在类中添加异常处理方法,在方法上创建@ExceptionHandler注解，value属性的值是异常的类型。在异常处理方法中封装错
误信息,返回json格式数据
```

### 27 说一说Map中的Hash算法 ？

```
如果key为null，返回0，不为null，则通过key的hash值的高16位异或key的hash值的低16位得到哈希值。不会造成因为高位
没有参与下标计算从而引起的碰撞。 
```

 例如:

![1693745551876](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1693745551876.png)

### 28 数据库的隔离级别有哪些？

```
读未提交会产生:脏读 不可重复读 幻读等问题。
当数据库系统使用读未提(READ UNCOMMITTED)隔离级别时，一个事务在执行过程中可以看到其他事务没有提交的新插入的记
录和更新的记录。

读已提交会产生:不可重复读  幻读等问题。
当数据库系统使用读已提交(READ COMMITTED)隔离级别时，一个事务在执行过程中能看到其他事务已经提交的新增和更新的
记录。

可重复读会产生:幻读
当数据库系统使用可重复读(REPEATABLE READ)隔离级别时，一个事务在执行过程中不能看到其他事务已经提交的更新的记
录,但是可以看到其他事务已经提交的新增的记录。MYSQL数据库的隔离级别是可重复读。但是MySQL的可重复读不会出现幻
读。

串行化
数据库系统使用串行化(SERIALIZABLE)隔离级别时，一个事务在执行过程中完全看不到其他事务对数据库所做的更
新。当两个事务同时操作数据库中相同数据时，如果第一个事务已经在访问该数据，第二个事务只能停下来等
待，必须等到第一个事务结束后才能恢复运行。因此这两个事务实际上是串行化方式运行。
```

### 29  隔离级别产生的问题

```
脏读（Dirty read）：一个事务读取到了另一个事务未提交的数据。
```

![1675476861765](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675476861765.png)

```
不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。
那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在
一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 
```

![1675476893572](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675476893572.png)

```
幻读。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事
务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
```

![1675476927635](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675476927635.png)

### 30 如何理解分布式和集群 ? 

集群

```
集群是是指将多台服务器集中在一起，每台服务器都实现相同的业务，做相同的事情。
```

分布式

```
分布式是指将多台服务器集中在一起，每台服务器都实现总体中的不同业务，做不同的事情。
```

### 31 事务的特性

```
原子性(Atomicity)
事务中的所有操作要么全部执行，要么都不执行。如果事务没有原子性的保证，那么在发生系统 故障的情况下，数据库就有
可能处于不一致状态。

一致性(Consistency)
主要强调的是，如果在执行事务之前数据库是一致的，那么在执行事务之后数据库也还是一致的。所谓一致性简单地说就是数
据库中数据的完整性，包括它们的正确性。

隔离性(Isolation)
即使多个事务并发（同时）执行，每个事务都感觉不到系统中有其他的事务在执行，因而也就能保证数据库的一致性。

持久性(Durability)
事务成功执行后它对数据库的修改是永久的，即使系统出现故障也不受影响。
```

### 32 数据库设计的三大范式有哪些?

```
第一范式(确保每列保持原子性) 第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值,就说明该数
据库表满足了第一范式。

第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关。就是说在一个数据库表中，
一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。
```

### 33 Redis 中基本类型有哪些?

```
string
list
set
zset
hash
```

### 34 Redis 中删除过期数据的策略?

```
Redis 采用定期删除和惰性删除的方式
定期删除，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。

惰性删除。在你获取某个 key 的时候，redis 会检查一下，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时
就会删除，不会给你返回任何东西。并不是 key 到时间就被删除掉，而是你查询这个 key 的时候，redis 再懒惰的检查一
下。
```

### 35 Redis 中的内存淘汰机制?

```
Redis 的内存淘汰策略是指在 Redis 的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。
noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
allkeys-lru： 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key
allkeys-lfu: 当内存不足以容纳新写入数据时，在键空间中， 移除使用次数最少的 key
allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key。
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的。
volatile-lfu：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除使用次数最少的 key
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除
```

### 36 SpringCloud 组件有哪些?

```
Nacos 	    当作服务注册发布中心 服务的配置中心
OpenFeign   用于远程服务调用
Sentinel    流量控制、熔断降级、系统负载保护
Gateway     网关
Ribbon      负载均衡工具
Seata       分布式事务解决方案
```

### 37 SpringMVC 的运行流程?

![1675479369070](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675479369070.png)

```
第一步：发起请求到前端控制器(DispatcherServlet)
第二步：前端控制器请求 HandlerMapping查找 Handler（可以根据 xml 配置、注解进行查找）
第三步：处理器映射器 HandlerMapping 向前端控制器返回 Handler，
第四步：前端控制器调用处理器适配器去执行Handler
第五步：处理器适配器 HandlerAdapter 将会根据适配的结果去执行 Handler
第六步：Handler 执行完成给适配器返回 ModelAndView
第七步：处理器适配器向前端控制器返回 ModelAndView
第八步：前端控制器请求视图解析器去进行视图解析
第九步：视图解析器向前端控制器返回View
第十步：前端控制器进行视图渲染
第十一步：前端控制器向用户响应结果
```

### 38  Redis持久化RDB的触发方式有哪些? 简述RDB的运行流程?

触发RDB的方式

```
符合自定义配置的快照规则
执行save或者bgsave命令
```

RDB的运行流程

```
1 执行bgsave命令时,Redis父进程判断当前是否有其他子进程正在执行,如果有其他进程正在执行,直接返回。
2 父进程执行fork操作创建子进程，这个复制过程中父进程是阻塞的，Redis不能执行来自客户端的任何命令。
3 父进程fork后，bgsave命令返回”Background saving started”信息并不再阻塞父进程,并可以响应其他命令。
4 子进程创建RDB文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行替换。
5 子进程发送信号给父进程表示完成，父进程更新统计信息。
```

![1675479542569](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675479542569.png)

### 39 简述AOF的运行流程? AOF重写的流程? AOF保存的模式?

AOF执行流程:

```
1 命令传播：Redis 将执行完的命令、命令的参数、命令的参数个数等信息发送到 AOF 程序中。 
2 缓存追加：AOF 程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将协议内容追加到服务器的AOF 缓
存中。 
3 文件写入和保存：AOF 缓存中的内容被写入到 AOF 文件末尾，如果设定的 AOF 保存条件被满足的话， fsync 函数或者 
fdatasync 函数会被调用，将写入的内容真正地保存到磁盘中。
```

AOF重写流程:

```
手动执行bg rewrite aof函数或者符合redis aof重写规则,主进程使用fork函数创建子进程,将redis内存中的数据重写到新
的aof文件中。

在aof重写的过程中,如果有新的命令发送给Redis执行,Redis会将新的命令放入到aof缓存区中,满足条件将缓存区的文件写入
到aof文件中。

同时新的命令会写入到aof重写缓存区中,在aof重写的时候,会将aof重写缓存区中的内容写到新的aof文件。

当重写完成,用新的aof文件替换原来的aof文件。
```

AOF的保存模式:

```
always(每次） 
•   每次写入操作均同步到AOF文件中， 数据零误差， 性能较低， 不建议使用。
everysec（每秒） 
•   每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高， 性能较高，建议使用，也是默认配置在系
统突然宕机的情况下丢失1秒内的数据 
no（系统控制）
•   由操作系统控制每次同步到AOF文件的周期，整体过程不可控
```

### 40 RDB与AOF的对比

```
rdb 是将redis中的数据进行持久化,存储速度比较慢,恢复速度比较快,rdb方式可以保存某一时刻的数据,但是数据会丢失。资
源消耗大。

aof 以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。存储速度比较快,恢复速度比
较慢,如果aof的策略是always,则redis的每个写命令都会保存到aof文件中,数据不会丢失,如果aof的策略是everysec,则每
秒将缓冲区中的指令同步到AOF文件中,有可能会丢失1s的数据。资源消耗低
```

### 41 缓存穿透是什么?解决方案有哪些? 缓存雪崩是什么?解决方案有哪些?

缓存穿透:

```
客户端，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也
没取到，那直接返回空结果。
```

解决方案:

```
对查询结果为空的情况进行缓存，缓存时间（ttl）设置短一点。
```

缓存雪崩:

```
缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是,缓存
击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
```

解决方案:

```
缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 
如果缓存数据库是分布式集群部署，将热点数据均匀分布在不同的缓存数据库中。 
设置热点数据永远不过期。 
```

缓存击穿:

```
缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，
又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。
```

![1675480090527](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675480090527.png)

解决方案:

```
1 设置热点数据永远不过期。
2 加互斥锁
```

### 42 Redis事务关键字有哪些,作用是什么?

```
Redis的事务是通过multi、exec、discard和watch这四个命令来完成的。Redis事务将命令集合序列化并确保处于同一事务
的命令集合连续且不被打断的执行。Redis不支持事务回滚操作。

关键字作用:
multi：用于标记事务块的开始,Redis会将后续的命令逐个放入队列中，然后使用exec原子化地执行这个命令队列
exec： 执行命令队列
discard：清除命令队列
watch：监视key 
unwatch：清除监视ke
```

### 43 Spring中bean的作用域有哪些?

```
1、singleton:单例，默认作用域。
2、prototype:原型，每次创建一个新对象。
3、request:请求，每次Http请求创建一个新对象，适用于WebApplicationContext环境下。
4、session:会话，同一个会话共享一个实例，不同会话使用不用的实例。
5、global-session:全局会话，所有会话共享一个实例
```

### 44 RabbitMQ如何保证消息队列中的消息不丢失?

```
(1)生产者开启确认机制,通过setConfirmCallback回调函数,确认信息是否到达交换机。通过setReturnCallback回调函数,
确认信息是否到达消息队列,进行后续处理。

(2)消息存储在rabbitMQ中,为了防止消息丢失,需要将消息进行持久化。

(4)消费阶段,将Rabbitmq的确认方式改为手动确认消息。消费方拿到消息以后,正确处理完业务以后,在调用basicAck方法手动
确认消息。如果业务处理错误,调用basicNack方法,将消息放回到队列中,重新从队列中获取消息。

(5)如果重复消费达到了预定的次数,将消息保存到死信中,同时发送警告信息
```

![保证消息不丢失与消费者消费信息的幂等性](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\保证消息不丢失与消费者消费信息的幂等性.jpg)

### 45 RabbitMQ工作模式有哪些?

路由模式

![1675480587379](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675480587379.png)

```
队列绑定到交换机的时候指定路由key;消息发送时需要携带路由key;消息的路由key与队列路由key完全一致才能让队列接收到
消息。
```

通配符模式

```
队列绑定到交换机的时候指定路由key；消息发送时需要携带路由key；消息的路由key与队列路由key匹配就能让队列接收到消
息。
```

![1675480686969](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675480686969.png)

 发布订阅模式

```
生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。
```

![1675480721205](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675480721205.png)

### 46 谈谈你对Spring的AOP理解?

```
AOP 能够将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，便于减少系统的重复代码，降低模块间的耦合度，并
有利于未来的可扩展性和可维护性。

Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理去创建代理对象；
而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib动态代理生成一个被代理对象的子类来作为代理。
```

### 47 SpringAOP 与  AspectJ的区别?

```
Spring AOP是属于运行时增强，而AspectJ是编译时增强。Spring AOP基于代理，而AspectJ基于字节码操作。

Spring AOP已经集成了AspectJ，AspectJ相比于Spring AOP功能更加强大，但是SpringAOP相对来说更简单。当切面太多的
话，最好选择AspectJ。
```

### 48 SpringAOP的增强有哪些?

```
before: 前置怎强，在一个方法执行前被调用。
after:最终增强, 在方法执行之后调用的，无论方法执行是否成功。
after-returning:后置增强, 仅当方法成功完成后执行的通知。
after-throwing:异常增强, 在方法抛出异常退出时执行的通知。
around: 环绕增强,在方法执行之前和之后调用的通知。
```

### 49 SpringBean的生命周期

```
1、Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化、
2、Bean实例化后对将Bean的引入和值注入到Bean的属性中
3、如果Bean实现了BeanNameAware接口，Spring将Bean的Id传递给setBeanName()方法中
4、如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入
5、如果Bean实现了ApplicationContextAware接口，Spring将调用Bean的setApplicationContext()方法，将bean所在
应用上下文引用传入进来
6、如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。
7、如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。如果bean使用init-
method声明了初始化方法，该方法也会被调用
8、如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。
9、此时Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。
10、如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法 如果bean使用了destory-method 声明
销毁方法，该方法也会被调用
```

### 50 Spring注入bean的几种方式?

```
set方法注入 

构造器注入: 通过index设置参数的位置   通过type设置参数类型
```

### 51 MySQL引擎有哪些

```
MYISAM：拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对较小，对事务完整性没有要求。

Innodb:行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持外键约束，并发能力强。

Memory:存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在mysql重启时会丢失，默认使用HASH索引，检索
效率非常高，但不适用于精确查找，主要用于那些内容变化不频繁的代码表
```

### 52  ES中的倒排索引原理

```
每个文档都有一个对应的文档ID,文档内容被拆分为一系列关键词的集合。对文档进行分词之后，得到倒排索引。有了倒排索
引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 Facebook ，搜索系统查找倒排索引，从中读出包含这个单词
的文档，这些文档就是提供给用户的搜索结果
```

![1675481176423](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675481176423.png)

### 53 分布式情况下如何保证ID的唯一性 

UUID

```
常见的方式,128位。可以利用数据库也可以利用程序生成，一般来说全球唯一。
优点： 
简单，代码方便。
全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对。
缺点：
没有排序，无法保证趋势递增。
UUID往往是使用字符串存储，查询的效率比较低。
存储空间比较大，如果是海量数据库，就需要考虑存储量的问题。
```

基于Redis INCR 命令生成分布式全局唯一ID

```
采用INCR命令来实现分布式全局ID生成
```

Twitter的snowﬂake算法

![1675482735608](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675482735608.png)

### 54 Seata的处理流程

```
1 事务管理器向事务协调者申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的事务ID。全局唯一的事务ID在微
服务调用链路的上下文中传播。
2 资源管理器向事务协调者注册分支事务，将其纳入全局唯一的事务ID对应全局事务的管辖中。
3 事务管理器向事务协调者发起针对全局唯一事务ID对应的全局事务是进行提交还是回滚。
4 资源管理器将全局事务ID对应的自己的本地事务进行提交还是回滚。
```

![1675482786690](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675482786690.png)

### 55 常用限流算法有哪些

1 计数器算法 

![1675482882427](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675482882427.png)

```
计数器算法是限流算法里最简单也是最容易实现的一种算法。比如我们规定，对于A接口来说，我们1分钟的访问次数不能超过
100个。那么我们可以这么做：在一开 始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加
1，如果counter的值大于100并且该请求与第一个请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个
请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置 counter。
```

2 令牌桶算法

```
1） 所有的请求在处理之前都需要拿到一个可用的令牌才会被处理； 2）、根据限流大小，设置按照定的速率往桶里添加令牌； 
3）、桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或
者拒绝； 4）、请求达到后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完
业务逻辑之后，将令牌直接删除； 5）、令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求
处理完之后将不会删除令牌，以此保证足够的限流；
```

![1675482966423](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675482966423.png)

3 漏斗算法

```
漏桶算法其实很简单，可以粗略的认为就是注水漏水过程，往桶中以一定速率流出水，以任意速率流入水，当水超过桶流量则丢
弃，因为桶容量是不变的，保证了整体的速率。
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675483018069.png" alt="1675483018069" style="zoom:50%;" />

### 56  Sentinel 熔断降级的方式有哪些

![1675483080141](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675483080141.png)

### 57 Forward 和 Redirect 的区别？

```
Forward 是服务器内部的重定向，服务器内部请求某个 servlet，然后获取响应的内容，浏览器的 URL 地址是不会变化的。
Redirect 是客户端请求服务器，然后服务器给客户端返回了一个 302 状态码和新的 location，客户端重新发起 HTTP请求,
服务器给客户端响应location 对应的 URL 地址，浏览器的 URL 地址发生了变化
```

### 58 InnoDB 引擎的数据库表,如果没有在表上创建主键,这张表上是否有主键 

```
如果表中没有定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。如果也没有这样的唯一索引，则
InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引 (ROWID随着行记录的写入而主键递增，这个ROWID不ORACLE的ROWID
那样可引用，是隐含的)。
```

### 59 Nginx 与 Ribbon都能实现负载均衡,他们的区别?

```
Nginx 所有请求统一交给nginx，由nginx进行实现负载均衡请求转发，属于服务器端负载均衡。请求由nginx服务器端进行转
发。

Ribbon 是从注册中心服务器端上 获取服务注册信息列表，缓存到本地，然后在本地调用远程服务接口。在客户端实现负载均
衡。
```

### 60 Left Join Inner Join Right Join的区别?

```
left join:“左连接”，左表连接右表，以左为主，表示以左表为主，关联上右表的数据，查出来的结果显示左边的所有数据，
然后右边显示的是和左边有交集部分的数据。

right join：“右连接”，右表连接左表，以右为主，表示以右表为主，关联查询左表的数据，查出右表所有数据以及左表和右
表有交集的数据。

join（inner join）:“内连接”，表示以两个表的交集为主，查出来是两个表有交集的部分，其余没有关联就不额外显示出
来。
```

### 61 程序计数器、栈、堆、方法区

```
程序计数器:线程私有的,作为当前线程的行号指示器,用于记录当前虚拟机正在执行的线程指令地址。

栈:线程私有的,每个方法执行的时候都会创建一个栈帧,用于存储局部变量表、操作数、动态链接和方法返回等信息。

堆:java堆是所有线程共享的一块内存，几乎所有对象的实例和数组都要在堆上分配内存，该区域经常发生垃圾回收的操作。

方法区:存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据。在jdk1.8中被元数据区替代了,原
方法区被分成两部分 1:加载的类信息 2:运行时常量池。加载的类信息被保存在元数据区中，运行时常量池保存在堆中。
```

### 62 可达性分析算法

```
从GC Roots的对象向下搜索，如果一个对象到GC Roots没有任何引用链相连接时，说明此对象不可用的。他们将会被判断为是
可回收的对象。
```

![1696777422276](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1696777422276.png)

### 63 强引用、软引用、 弱引用有什么区别？ 

```
- 强引用，就是普通的对象引用关系，如 String s = new String("ConstXiong")

- 软引用，用于维护一些可有可无的对象。只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有
足够的内存，才会抛出内存溢出异常。 (SoftReference)

- 弱引用，相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾回收时，无论内存是否充足，都会回
收被弱引用关联的对象。(WeakReference)
```

### 64 有哪几种垃圾回收器，各自的优缺点是什么?

```
- Serial:单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。
- ParNew:Serial收集器的多线程版本，也需要stop the world，使用复制算法。
- CMS:是一种以获得最短回收停顿时间为目标的收集器,收集结束会产生大量空间碎片。
- G1:不会产生空间碎片，可以精确地控制停顿；G1将整个堆分为大小相等的多个Region（区域），G1跟踪
每个区域的垃圾大小，在后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值最大的区域，已
达到在有限时间内获取尽可能高的回收效率。
```

### 65 G1垃圾回收器一次完整的GC是什么样子的？

```
1 对象优先在Eden分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。
(1) 在Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区；
(2) Eden 区再次 GC，这时会采用复制算法，将 Eden 和 from 区一起清理，存活的对象会被复制到 to 区；
(3) 移动一次，对象年龄加 1，对象年龄大于一定阀值会直接移动到老年代。GC年龄的阀值可以通过参数 -
XX:MaxTenuringThreshold 设置，默认为 15；
(4) 动态对象年龄判定：Survivor 区相同年龄所有对象大小的总和 > (Survivor 区内存大小 * 这个目标使用率)时，大于
或等于该年龄的对象直接进入老年代。其中这个使用率可以通过 -XX:TargetSurvivorRatio 指定，默认为 50%；
(5) Survivor 区内存不足会发生担保分配，超过指定大小的对象可以直接进入老年代。
2 大对象直接进入老年代，大对象就是需要大量连续内存空间的对象（比如：字符串、数组），为了避免为大对象分配内存时
由于分配担保机制带来的复制而降低效率。
3 老年代内存空间占堆内存的45%触发混合回收。混合回收会回收年轻代和老年代的Region。一旦空闲出来的Region占整个堆
内存的5%,就会停止混合回收。在混合回收的过程中,发现没有空闲的Region可以承载存活的对象,就会触发一次失败。一旦失
败，就会触发Full GC。立马就会切换为停止系统程序，然后采用单线程进行标记、清理和压缩整理，空闲出来一批Region，
这个过程很慢。
```

### 66 Minor GC/Young GC      Full GC      Mixed GC有什么不同呢？

```
Minor GC/Young GC: 只收集新生代的GC。

Full GC: 收集整个堆，包括 新生代，老年代，永久代(在 JDK 1.8及以后，永久代被移除，换为metaspace 元空间)等所有
部分的模式。

Mixed GC 在G1垃圾回收器中，一旦老年代占据堆内存的45%了，就要触发MixedGC，此时对年轻代和老年代都会进行回收。
```

### 67 介绍下空间分配担保原则？

```
如果YougGC时新生代有大量对象存活下来，而survivor 区放不下了，这时必须转移到老年代中，但这时发现老年代也放不下
这些对象了，那怎么处理呢？其实JVM有一个老年代空间分配担保机制来保证对象能够进入老年代。

在执行每次 YoungGC 之前，JVM会先检查老年代最大可用连续空间是否大于新生代所有对象的总大小。因为在极端情况下，可
能新生代 YoungGC 后，所有对象都存活下来了，而 survivor 区又放不下，那可能所有对象都要进入老年代了。这个时候如
果老年代的可用连续空间是大于新生代所有对象的总大小的，那就可以放心进行 YoungGC。但如果老年代的内存大小是小于新
生代对象总大小的，那就有可能老年代空间不够放入新生代所有存活对象，这个时候JVM就会先检查 -
XX:HandlePromotionFailure 参数是否允许担保失败，如果允许，就会判断老年代最大可用连续空间是否大于历次晋升到老
年代对象的平均大小，如果大于，将尝试进行一次YoungGC，尽管这次YoungGC是有风险的。

在允许担保失败并尝试进行YoungGC后，可能会出现三种情况：
- ① YoungGC后，存活对象小于survivor大小，此时存活对象进入survivor区中
- ② YoungGC后，存活对象大于survivor大小，但是小于老年大可用空间大小，此时直接进入老年代。
- ③ YoungGC后，存活对象大于survivor大小，也大于老年大可用空间大小，老年代也放不下这些对象了，
此时就会发生“Handle Promotion Failure”，就触发了 Full GC。

如果老年代最大可用连续空间小于历次晋升到老年代对象的平均大小，或者 -XX:HandlePromotionFailure 参数不允许担保
失败，这时就会进行一次 Full GC。

如果Full GC后，老年代还是没有足够的空间，此时就会发生OOM内存溢出了。
```

### 68 被引用的对象就一定能存活吗？

```
软引用，在内存不足时，系统则会回收软引用对象。弱引用，当 JVM 进行垃圾回收时，无论内存是否充足，都会被回收。
```

### 69 详细说一下CMS的回收过程？

```
CMS收集器是以获取最短回收停顿时间为目标的收集器，它在垃圾收集时使得用户线程 GC线程并发执行，因此在垃圾收集过程
中用户也不会感到明显的卡顿。
CMS是基于“标记-清除”算法实现的。CMS 回收过程分为以下四步：
1. 初始标记 （CMS initial mark)：首先，CMS要进行垃圾回收时，会先执行初始标记阶段，这个阶段会让系统的工作线程
全部停止，进入“stop the world”状态。所谓的“初始标记,标记出来所有GC Roots直接引用的对象。

2. 并发标记 (CMS concurrent mark)：根据上一步的结果，标记处被GC Roots间接引用的对象，虽然耗时理论上会比较
长，但是其它工作线程并不会阻塞，没有 STW。

3. 重新标记（CMS remark）：顾名思义，就是要再标记一次。为啥还要再标记一次？因为第 2 步并没有阻塞其它工作线
程，其它线程在标识过程中，很有可能会产生新的垃圾。

4. 并发清除（CMS concurrent sweep）：清除阶段是清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对
象，所以这个阶段也是可以与用户线程同时并发进行的。
```

### 70 CMS的问题

```
1. 并发回收导致CPU资源紧张：
在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低程序总吞吐量。CMS默
认启动的回收线程数是：（CPU核数 + 3）/ 4，当CPU核数不足四个时，CMS对用户程序的影响就可能变得很大。

2. 无法清理浮动垃圾：
在CMS的并发标记和并发清理阶段，用户线程还在继续运行，就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出
现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留到下一次垃圾收集时再清理掉。这一部分垃圾称为“浮动垃
圾”。

3. 并发失败（Concurrent Mode Failure）：
由于在垃圾回收阶段用户线程还在并发运行，那就还需要预留足够的内存空间提供给用户线程使用，因此CMS不能像其他回收
器那样等到老年代几乎完全被填满了再进行回收，必须预留一部分空间供并发回收时的程序运行使用。默认情况下，当老年代
使用了 92% 的空间后就会触发 CMS 垃圾回收，这个值可以通过 -XX: CMSInitiatingOccupancyFraction 参数来设置。
这里会有一个风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”
（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：Stop The World，临时启用 Serial Old 来重新
进行老年代的垃圾回收，这样一来停顿时间就很长了。

4.内存碎片问题：
CMS是一款基于“标记-清除”算法实现的回收器，这意味着回收结束时会有内存碎片产生。内存碎片过多时，将会给大对象分配
带来麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 
Full GC 的情况。-XX:CMSFullGCsBeforeCompaction，这个参数的作用是要求CMS在执行过若干次不整理空间的 Full GC 
之后，下一次进入 Full GC 前会先进行碎片整理（默认值为0，表示每次进入 Full GC 时都进行碎片整理）。
```

### 71 什么是双亲委派模型? 为什么需要双亲委派模型?

```
当一个类加载器收到一个类加载的请求，他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载，只有父类加载
器在自己的搜索范围类查找不到给类时，子加载器才会尝试自己去加载该类；

为了防止内存中出现多个相同的字节码；因为如果没有双亲委派的话，用户就可以自己定义一个java.lang.String类，那么就
无法保证类的唯一性。
```

### 72 如何保证消息的顺序性?

```
解决消费顺序的问题，通常就是一个队列只有一个消费者。这样就可以一个个消息按顺序处理，缺点就是并发能力下降了，无法
并发消费消息。

如果业务又要顺序消费，又要增加并发，通常思路就是开启多个队列，按照业务根据规则将消息分发到不同的队列，通过增加队
列的数量来提高并发度。 例如：保证同一个用户的订单消息的顺序性，只要让同一个用户的订单消息进入同一个队列就行。
```

### 73 消息队列中的消息为什么会重复消息?

```
（1）生产者重复发送消息：生产者在往消息队列发送消息时，发生了网络抖动，生产者没有收到确认信号，但是实际上消息队
列已经收到了消息，超过一定时间后生产者会重新发送消息，这时一条消息被发送了两次；

（2）消费者重复接受消息：消费者成功消费消息后，发生了网络抖动，消息队列没有收到确认信号，超过一段时间后会重新给
消费者投递相同的消息，同一条消息即存在被消费两次的可能。
```

### 74 消息队列中的消息如何防止重复消费?

```
在消息实体中添加全局唯一的消息id(msg_d)。消费者在收到消息之后，根据 msg_id 从缓存或者数据库中查询是否存在已有
消息；如果不存在已有消息，那么消费之后，将 msg_id对应的消息写入缓存。如果存在已有消息，说明这条消息已被消费过，
丢弃消息并且打一条告警日志。
```

### 75 Spring Boot、Spring MVC 和 Spring 有什么区别？

```
spring 框架就像一个家族，有众多衍生产品。但他们的基础都是Spring 的 ioc和 aop。 ioc 提供了依赖注入的容器。aop 
解决了面向横切面的编程，然后在此两者的基础上实现了其他延伸产品的高级功能。

Spring MVC是基于 Servlet 的一个 MVC 框架 主要解决 WEB 开发的问题。

因为 Spring 的配置非常复杂。于是为了简化开发者的使用，从而推出了Spring boot，约定优于配置，简化spring的配置流
程。
```

### 76 如何保证线程的安全性？

```
1 公共资源不可变，线程一定安全
public class NoChangeService {
    public static final String DEFAULT_NAME = "abc";
        public void add(String status) {
            System.out.printIn(DEFAULT_NAME);
        }


    }
} 
2 不提供修改入口，属性私有化
3 使用Synchronized关键字, 创建同步方法和同步代码块
4 使用ReentrantLock类
5 使用分布式锁
对于synchronized和lock对于单个节点可以保证线程安全，但是不同节点的分布式环境无法保证，这
时可以使用分布式锁
6 volatile
如果只要求多个线程之间的可见性，使用volatile就可以
7 ThreadLocal
8 使用线程安全的集合
9 CAS机制
```

### 77 项目中在什么位置使用了多线程

一  线程异步编排

具体场景

```
查询商品信息时,商品信息太多。将查询信息放在不同的线程中执行,等所有线程都查询完结果,在一起返回数据。
```

二  异步任务

具体场景

```
在新增优惠券模板时,当优惠券模板新增完毕以后,优惠券的模板为不可用状态。调用异步任务 根据优惠券模板的规则生成优惠
券码保存到Redis中,此时才将优惠券模板设置为可用状态。
```

三 ThreadLocal

具体场景

```
同一个请求具有相同的请求ID
```

四  信号量

具体场景

```
商品秒杀
```

### 78 项目中使用了哪些设计模式

一  优惠券结算服务中使用了: 工厂模式 + 策略模式

```
优惠券执行管理器根据结算请求时传入的优惠券类型,调用不同的结算方法。如果是满减优惠券调用满减优惠券结算方法,如果是
满减+折扣优惠券,调用满减折扣优惠券结算方法。
```

1.1 工厂模式基础知识

```
工厂模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，
并且是通过使用一个共同的接口来指向新创建的对象。

主要解决：主要解决接口选择的问题。
何时使用：我们明确地计划不同条件下创建不同实例时。
如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。
```

1.2 工厂模式最基础的代码

![1675489800942](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675489800942.png)

```
public interface Shape {
 void draw(); 
}
public class Rectangle implements Shape { 
    @Override 
    public void draw() { 
        System.out.println("Inside Rectangle::draw() method."); 
    } 
}
public class Square implements Shape { 
    @Override
     public void draw() { 
        System.out.println("Inside Square::draw() method."); 
     } 
}
public class Circle implements Shape {
     @Override 
     public void draw() { 


        System.out.println("Inside Circle::draw() method.");
     } 
}
public class ShapeFactory { 
    //使用 getShape 方法获取形状类型的对象 
    public Shape getShape(String shapeType){ 
        if(shapeType == null){
            return null; 
        } 
        if(shapeType.equalsIgnoreCase("CIRCLE")){ 
            return new Circle(); 
        } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
            return new Rectangle(); 
        } else if(shapeType.equalsIgnoreCase("SQUARE")){
             return new Square(); 
        } 
        return null;
     } 
}
public class FactoryPatternDemo { 
        public static void main(String[] args) { 
                ShapeFactory shapeFactory = new ShapeFactory(); 
                //获取 Circle 的对象，并调用它的 draw 方法
                 Shape shape1 = shapeFactory.getShape("CIRCLE");
                 //调用 Circle 的 draw 方法
                 shape1.draw();
        }
}
```

1.3 策略模式

```
在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。在策略模式中，我们创建表示各种策略的对
象和一个行为随着策略对象改变而改变的 context 对象。

主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。
何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。
如何解决：将这些算法封装成一个一个的类，任意地替换。
```

1.4 策略模式的基础代码

![1675489862535](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675489862535.png)

![1675489872281](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675489872281.png)

![1675489880942](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675489880942.png)

![1675489889376](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675489889376.png)

![1675489898245](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675489898245.png)

1.5 策略模式和工厂模式一起使用

```
定义
策略模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
工厂模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
优势
策略模式：暴露了策略类，每次使用策略都要new一个新的对象。可以使用工厂模式生产策略类。
```

基础代码

```
策略枚举类:
public enum StrategyEnum {
    //策略1
    CONCRETESTRATEGY1("ConcreteStrategy1", "策略1"),
    //策略2
    CONCRETESTRATEGY2("ConcreteStrategy2", "策略2");
    private String strategyName;
    private String strategyDesc;

    StrategyEnum(String strategyName, String strategyDesc) {
        this.strategyName = strategyName;
        this.strategyDesc = strategyDesc;
    }
    public String getStrategyName() {
        return strategyName;
    }
}
```

策略工厂,用于保存和获取策略

```
public class Factory {
    private static Map<String, Strategy> factory = new ConcurrentHashMap<>();
    /**
     * 生产策略产品
     */
    static {
        factory.put(StrategyEnum.CONCRETESTRATEGY1.getStrategyName(), new
ConcreteStrategy1());
        factory.put(StrategyEnum.CONCRETESTRATEGY2.getStrategyName(), new
ConcreteStrategy2());
    }
    /**
     * 获取策略
     *
     * @param strategyName
     * @return
     */
    public static Strategy getStrategy(String strategyName) {
        return factory.get(strategyName);
    }
    /**
     * 注册策略
     *
     * @param strategyName
     * @param Strategy
     */
    public static void register(String strategyName, Strategy Strategy) {
        factory.put(strategyName, Strategy);
    }
}
```

策略接口

```
public interface Strategy {
    /**
     * 策略要执行的方法
     */
    void strategyMethod();
}
```

具体策略

```
public class ConcreteStrategy1 implements Strategy {
    /**
     * 策略方法
     */
    @Override
    public void strategyMethod() {
        System.out.println("具体策略1的执行方法");
    }
}

public class ConcreteStrategy2 implements Strategy {
    /**
     * 策略方法
     */
    @Override
    public void strategyMethod() {
        System.out.println("具体策略2的执行方法");
    }
}
```

程序入口

```
public class Application {
    public static void main(String[] args) {
        Strategy strategy1 = Factory.getStrategy("ConcreteStrategy1");
        strategy1.strategyMethod();

        Strategy strategy2 = Factory.getStrategy("ConcreteStrategy2");
        strategy2.strategyMethod();
    }
}
```

二 项目的通用模块中都使用了AOP,  记录用户的操作日志 和 自动翻译系统返回的常量值

2.1 代理模式

```
定义: 代理模式就是代理对象具备真实对象的功能，并代替真实对象完成相应操作，并能够在操作执
行的前后，对操作进行增强处理。
```

2.2 静态代理模式

![1675490108299](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675490108299.png)

```
public interface IRentHouse {
    void rentHouse();
}
public class RentHouse implements IRentHouse {
    @Override


    public void rentHouse() {
        System.out.println("实现租房");
    }
}
public class IntermediaryProxy implements IRentHouse {
    private IRentHouse iRent;
    public IntermediaryProxy(IRentHouse iRentHouse) {
        iRent=iRentHouse;
    }
    @Override
    public void rentHouse() {
        System.out.println("交中介费");
        iRent.rentHouse();
        System.out.println("中介负责维修管理");
    }
}
//client测试类
public class TestStaticProxy {
    public static void main(String[] args) {
        //定义租房
        IRentHouse iRentHouse = new RentHouse();
        //定义中介
        IRentHouse intermediaryProxy = new IntermediaryProxy(iRentHouse);
        //中介租房
        intermediaryProxy.rentHouse();
    }
}
```

2.3 动态代理

```
从静态代理的代码中可以发现，静态代理的缺点显而易见，那就是当真实类的方法越来越多的时候，这样构建的代理类的代码量是非常大的，所以就引进动态代理。

动态代理允许使用一种方法的单个类（代理类）为具有任意数量方法的任意类（真实类）的多个方法调用提供服务。
```

2.3.1 基于接口的方式实现动态代理

```
//接口1
public interface Person {
    void wakeup();
    void sleep();
}
//实现类1
public class Student implements Person{
    private String name;
    public Student() {
    }
    public Student(String name) {
        this.name = name;
    }
    @Override
    public void wakeup() {
        System.out.println("学生"+name+"早晨醒来啦");
    }
    @Override
    public void sleep() {
        System.out.println("学生"+name+"晚上睡觉啦");
    }
}
```

//代理类

```
public class JDKDynamicProxy implements InvocationHandler {
    private Object bean;
    public JDKDynamicProxy(Object bean) {
        this.bean=bean;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws
Throwable {
        String methodname=method.getName();
        if (methodname.equals("wakeup")){
            System.out.println("早安~~~");
        }else if(methodname.equals("sleep")){
            System.out.println("晚安~~~");
        }
        return method.invoke(bean,args);
    }
}
```

//测试类

```
  public class TestJDKDynamicProxy {
    public static void main(String[] args) {
        JDKDynamicProxy proxy = new JDKDynamicProxy(new Student("张三"));
        //创建代理实例
        Person student = (Person)
			Proxy.newProxyInstance(proxy.getClass().getClassLoader(), new Class[]
				{Person.class}, proxy);
        student.wakeup();
        student.sleep();
	}
}
```

2.3.2 cglib动态代理

```
CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。
CGLIB通过继承方式实现代理。
```

```
<dependency>
       <groupId>cglib</groupId>
       <artifactId>cglib</artifactId>
       <version>3.1</version>
</dependency>

public class AliSmsService {
    public String send(String message){
        System.out.println(“send message:" + message);
        return message;
    }
} 

自定义方法拦截器:
public DebugMethodInterceptor  impltements MethodInterceptor{
    /**
     * @param o           被代理的对象（需要增强的对象）
     * @param method      被拦截的方法（需要增强的方法）
     * @param args        方法入参
     * @param methodProxy 用于调用原始方法
     */
    public Object intercept(Object o, Method method, Object[] args, MethodProxy
methodProxy) throws Throwable {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method " + method.getName());
        Object object = methodProxy.invokeSuper(o, args);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method " + method.getName());
        return object;
    }
}

public class CglibProxyFactory (
    public static Object getProxy(Class<?> clazz) [
        // 创建动态代理增强类
        Enhancer enhancer = new Enhancer();
        // 设置类加载器
        enhancer.setClassLoader(clazz.getClassLoader());
        // 设置代理类
        enhancer.setSuperclass(clazz);
        // 设置方法趋截器
        enhancer.setCallback(new DebugMethodInterceptor());
        // 创建代理类
        return enhancer.create();
    }
}

public class Test{
    public static void main(String []args){
        AliSmsService aliSmsService = (AliSmsService)
			CglibProxyFactory.getProxy(AliSmsService.class);
        aliSmsService.send("java");
    }
} 
```

三 单例模式: 类的对象只有一个。

饿汉式单例模式:

```
public class Singleton {
    private  final static Singleton instance=new Singleton();
    private Singleton(){
    }
    public static Singleton getInstance(){
        return instance;
    }
}
```

懒汉式单例模式: 双重检查写法

```
public class Singleton3 {
    private volatile static Singleton3 instance;
    private Singleton3(){
    }
    //使用双重检查。第一个线程先执行到第17行代码,获得锁,判断instance对象是否为空,如果为
空则创建对象
    //同时第二个线程也执行到了第17行代码,因为第一个线程先获得锁,第二个线程等待第一个线程
执行完毕以后
    //在向下执行,判断instance是否为空,因为第一个线程已经创建了对象。所以第二个线程就不需
要在创建对象。
    //使用volatile关键字的原因是防止程序的重排序,因为重排序有可能会产生第一个线程在创建
对象的过程中
    //此时第二个线程获得对象,有可能会将第一个线程还没有创建好的对象直接返回
    public static Singleton3 getInstance(){
        if(instance==null){
            synchronized (Singleton3.class) {
                if(instance==null){
                    instance=new Singleton3();
                }
            }
        }
        return instance;
    }
}
```

懒汉式单例模式:内部类写法

``` 
public class Singleton4 {
    private Singleton4(){
    }
    private static class SingletonInstance{
        private static  final Singleton4 instance=new Singleton4();
    }
    public static Singleton4 getInstance(){
        return SingletonInstance.instance;
    }
}
```

四 模板模式

```
包装了一个通用的RabbitMQ模块,在消费者消费信息的时候,处理的业务方法不同,其他的代码都是相同的。所以将业务方法定义成了一个抽象方法,具体消费信息的类实现抽象的处理业务的方法。
```

### 79 什么是反射

```
JAVA 反射机制是在运行状态中，对于任意一个类，都能够调用这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。
```

### 80 事务传播类型

```
REQUIRED：如果当前没有事务，则自己新建一个事务，如果当前存在事务则加入这个事务。

SUPPORTS:当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行。

MANDATORY:当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。

REQUIRES_NEW:创建一个新事务，如果存在当前事务，则挂起该事务。

NOT_SUPPORTED:以非事务方式执行,如果当前存在事务，则挂起当前事务。

NEVER: 如果当前没有事务存在，就以非事务方式执行。如果有就抛出异常。就是B从不以事务方式运行。

NESTED嵌套事务:如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样(开启一个事务)。
```

### 81 SQL语句调优

一  使用Explain关键字查看SQL语句的执行计划

```
常见列名:
id    				查询编号
type                本次查询表连接的类型
possible_keys       可能使用的索引
key                 实际使用的索引
extra               附件信息
select_type         查询类型
```

type列的取值:

```
const: 查询条件主键或者唯一索引
ref:  查询条件是非聚簇索引
ref_or_null: 查询条件是非聚簇索引并且条件是is null
range: 查询条件是一个范围
index: 查询的所有字段都是非聚簇索引的字段。
all: 全表扫描
```

id的值的作用:

![1675738017477](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675738017477.png)

extra显示的内容

```
using filesort: 排序时没有使用索引
using tempoary: 分组时没有使用索引
```

二 索引使用的一些规则

```
1 表中的索引不能太多
2 一般情况下2-3个组合索引 配合1-2个单字段索引进行查询
3 主键索引是有序的
4 where     order by    group by  组合索引组好能够覆盖where   group by   order by 如果覆盖不了,尽量让
where字段使用索引
5 如果字段的取值比较少,可以不用索引
6 不要在索引上进行计算,不要在索引使用函数
```

三 组合索引的规则

```
 1 组合索引尽量满足等值匹配原则    最左匹配原则    如果有范围查询,将范围查询的条件放到组合索引的最后
 2 like语句操作  应该写成 like “值%”
```

四 列表查询的规则

```
1 如果是表连接查询,小表驱动大表。inner join 会自动选择小表作为驱动表。left join 将左边的表当作驱动表,所以left 
join应该将小表放到左边。right join将右边的表当作驱动表,所以right join应该将小表放到右边。
2 连表查询,给连接字段添加索引
```

其他的:

```
1、尽量避免使用select * 查询
2、索引不要包含有NULL值的列:只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这
一列对于此复合索引就是无效的。  
3 如果使用in关键字,in关键字后面的数据不要太多。
4 force_index 强制MySQL必须使用某个索引进行查询
5、减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代
4、or的查询尽量用 union 或者 union all代替
6、应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。
```

### 82 String    StringBuffer    StringBuilder

```
String类是不可变类，String对象一旦创建，其值是不能修改的，如果要修改，会重新开辟内存空间来存储修改之后的对象,
而StringBuffer和StringBuilder对象的值是可以被修改的。

StringBuffer和StringBuilder类则是可变长度字符串，他俩的原理和操作基本相同，任何对它所指代的字符串的改变都不
会产生新的对象。StringBuffer几乎所有的方法都使用synchronized实现了同步，支持并发操作，线程安全，在多线程系统
中可以保证数据同步，但是效率比较低；StringBuilder线程不安全，不支持并发操作，不能同步访问，不适合多线程中
使用。
但是效率比较高。

需要对字符串进行频繁的修改，不要使用String，否则会造成内存空间的浪费。考虑线程安全的场合使用String
Buffer，如果不需要考虑线程安全，追求效率的场合可以使用 StringBuilder。
```

### 83 Servelt生命周期

加载和实例化

```
在servlet容器（例如Tomcat等）第一次接收到请求后，会进行一个解析，然后实例化 servlet。
```

初始化

```
servlet 容器调用 servlet 的init方法进行初始化，完成一些准备工作。在整个 servlet 的生命周期中，init() 方法只
会被调用一次,也就是只会初始化一次。
```

服务

```
servlet容器调用servlet的service方法，去根据客户端的请求方式，去选择一个方法执行（doget   dopost）get请求方式
是doget方法，post请求方式是dopost方法，对客户的请求做处理，然后对客户作出一个响应
```

销毁

```
servlet 容器的最后一个阶段，调用 destroy() 方法，销毁创建的对象，整个servlet 生命周期也就结束了。在整个生命周
期里，destroy() 方法只会被调用一次。
```

### 84 Filter(过滤器) 生命周期

实例化

```
在服务器启动时调用过滤器的构造方法, 构造器只会调用一次。
```

初始化

```
初始化调用init()方法,在实例化后被调用。
```

过滤

```
每一次拦截请求时都会调用。
```

销毁

```
Web应用卸载前,Web容器调用 destroy 方法,在该方法中执行资源释放。
```

### 85 拦截器  过滤器  监听器的区别

```
过滤器：是web服务器的，可以拦截任何资源。
监听器：是web服务器的，监听特定事件的发生。
拦截器：是SpringMVC的，不会拦截静态资源，只会拦截访问的控制器方法handler，拦截的时机是handler运行前、运行完了
但未跳转页面之前、跳转页面之后。
```

### 86 Spring支持的几种Bean的作用域

```
singleton： 默认，每个容器中只有一个bean的实例。
prototype： 为每一个bean请求提供一个实例。
request：   为每一个请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。
session：   每个session中有一个bean的实例，在session过期后bean会随之失效。
global-session：全局作用域。
```

### 87  @AutoWired 与 @Resource的区别

```
1.提供方不同
@Autowired 是Spring提供的， @Resource Java本身提供的
2.装配时默认类型不同
@Autowired只按type装配, @Resource默认是按name装配。
```

### 88 索引是什么

索引是什么 

```
索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。一
般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的。
```

有哪些索引

```
包括聚集索引、组合索引、唯一索引
```

唯一索引与主键索引的区别

```
主键一定是唯一性索引，    唯一性索引并不一定就是主键。
一个表中可以有多个唯一性索引，但只能有一个主键。
主键列不允许空值，而唯一性索引列允许空值。
```

### 89 == 与 equals方法的区别

```
“==”用来比较基本类型的数据,比较的是他们的值。引用数据类型用“==”比较的是他的内存地址。

“equals”对于引用数据类型比较的也是它的内存地址。String（还有Date，Integer）类型重写了equals方法，使其比较的是
存储对象的内容是否相等。
```

### 90 异常处理的关键字

```
try:     指定一块预防所有“异常”的程序。
catch:   紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的“异常”的类型。
throw:   用来明确地抛出一个“异常”。在方法中使用,抛出异常对象。
throws:  在方法上使用,声明方法要抛出异常,后面跟异常类型。
finally: 不管发生什么“异常”都被执行一段代码。
```

### 91 HTTP 响应码有哪些?分别代表什么含义?

```
200：成功，Web 服务器成功处理了客户端的请求。
301：永久重定向，当客户端请求一个网址的时候，Web 服务器会将当前请求重定向到另一个网址，搜索引擎会抓取重定向后网
页的内容并且将旧的网址替换为重定向后的网址。
302：临时重定向，搜索引擎会抓取重定向后网页的内容而保留旧的网址，因为搜索引擎认为重定向后的网址是暂时的。
400：客户端请求错误，多为参数不合法导致 Web 服务器验参失败。
404：未找到，Web 服务器找不到资源。
500：Web 服务器错误，服务器处理客户端请求的时候发生错误。
503：服务不可用，服务器停机。
504：网关超时。
```

### 92 JMS两种消息模型

点到点（P2P）模型

```
使用队列（Queue）作为消息通信载体；满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中
保留直到被消费或超时。
```

发布/订阅（Pub/Sub）模型

```
发布订阅模型（Pub/Sub） 使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传
递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。
```

### 93 为什么用消息队列

```
异步：
   
   
解耦：

  
削峰：


```

### 94 封装 继承 多态

```
封装，即隐藏对象的属性和实现细节，仅对外公开接口（方法/函数），控制在程序中属性的读和修改的访问级别。
 
继承可以使得子类具有父类的非私有属性和方法(不能继承构造方法 只能调用构造方法) 或者可以重新定义、追加属性和方
法。

多态: 就是同一个行为具有多个不同表现形式。
```

### 95 如何自定义注解

```
@Retention: 表示该注解的生命周期，是RetentionPolicy类型的，可以是：CLASS、RUNTIME、SOURCE。		
source：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；被编译器忽略。
	class：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期
	runtime：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在。

@Target: 表示该注解的作用范围，是ElementType类型的。可以是Field  Method  PARAMETER等
```

### 96 Spring框架的常用注解有哪些？

```
@Controller:用于标注控制层组件
@RestController:当于@ Controller和@responseBody的组合效果
@Component:泛指组件当组件不好归类的时候，我们可以使用这个组件进行标注
@Repository：用于注解dao层，在daoimpl类上面注解
@Service:用于标注业务层组件
@ResponseBody:异步请求
@RequestMapping:一个用来处理请求地址映射的注解；可用于类或方法上用于类上，表示层中的所有响应请求的方法都是以
地址作为父路径。
@Autowired:它可以对类成员变量、方法及构造函数进行标注，完成自动装配工作。
@PathVarlable:用于将请求URL中的模版变量映射到功能处理方法的参 数上，即取出URL模版中的变量作为参数。
@requestParam:主要用于在SpringMVC后台控制层获取参数。
@Valid:实体数据校验，可以结合Hibernate validator一起使用。
```

### 97 抽象类与接口的区别

```
(1)接口中的可以有默认方法,抽象方法,接口中没有变量都是常量。
(2)抽象类中的方法可以是抽象方法,也可以不是抽象方法。
(3)抽象类中含有构造方法,接口中不能含有构造方法。
(4)抽象类中可以有变量也可以有常量。
(5)一个类只能继承一个抽象类,可以实现多个接口。
```

### 98 RabbitMQ中解决消息过期问题

1 大量的MQ集合

```
一般这个时候，只能临时紧急扩容了，先修复消费者的问题，确保其恢复消费速度，然后将现有消费者都停掉。写一个临时的分
发数据的消费者程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的队列中
(临时队列的数量可以是原来消息队列数量的N倍)。然后接着临时征用机器来部署消费者，每一个消费者消费一个临时队列的数
据。这种做法相当于是临时将 队列资源和 消费者资源扩大N倍，以正常的N倍速度来消费数据。等快速消费完积压数据之后，
得恢复原先部署的架构，重新用原先的 消费者机器来消费消息。
```

2 MQ中的消息大量积压,到时消息过期失效

```
假设用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 队列中积压超过一定的时间就会被 
RabbitMQ 给清理掉，这个数据就没了。积压最后导致消息队列中大量的消息直接丢失。在系统压力不是特别大的时候,写个程
序将丢失的那批数据，一点一点的查出来，然后重新灌入 mq 里面去。

假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手
动发到 mq 里去再补一次。
```

### 99 JSP的内置对象有哪些?分别有什么作用?

```
application对象:该实例对象代表JSP所属的Web应用本身，可用于JSP页面，或者在Servlet之间交换信息。
config对象:代表当前JSP的配置信息，但JSP页面通常无须配置，因此也就不存在配置信息。
exception对象:是Throwable的实例，代表JSP脚本中产生的错误和异常，是JSP页面异常机制的一部分。
out对象:代表一个页面的输出流，通常用于在页面上输出变量值及常量。
pageContext对象:该对象代表上下文，该对象主要用于访问JSP之间的共享数据。
request对象:用于封装请求的客户端的请求信息。
response对象:用于封装服务器对客户端的响应数据。
session对象:用于保存会话数据。从客户端浏览器连接服务器开始，到客户端浏览器与服务器断开为止，这个过程就是一次会
话。
page对象page对象有点类似于Java编程中的this指针，就是指当前JSP页面本身。page是java.lang.Object类的对象
```

### 100 synchronized关键字与volatile关键字

synchronized关键字

```
synchronized可以修饰普通方法，静态方法和代码块。
当synchronized修饰一个方法或者一个代码块的时候，它能够保证在同一时刻最多只有一个线程执行该段代码。当一个线程试
图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。
synchronized可以保证线程的原子性。
```

 volatile 

```
volatile的性能比synchronized要高。volatile只能修饰变量。
一个变量加了volatile关键字，就会告诉编译器和JVM的内存模型：这个变量是对所有线程共享的、可见的，每次jvm都会读取
最新写入的值并使其最新值在所有CPU可见。
volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性。
```

### 101  equlas方法与hashcode方法

```
1）equals() 的作用是用来判断两个对象是否相等。
2）hashCode() 的作用是获取对象的哈希码；哈希码一般是一个整数，用来确定对象在哈希表（比如 HashMap）中的索引位
置。拿 HashMap 来说，它本质上是通过数组实现的。当我们要获取某个“值”时，实际上是要获取数组中的某个位置的元素。而
数组的位置，就是通过“键”来获取的；更进一步说，是通过“键”对应的哈希码计算得到的。
3）如果两个对象需要相等（equals），那么它们必须有着相同的哈希码（hashCode）；
4）但如果两个对象有着相同的哈希码，它们却不一定相等。
```

### 102 Redis的使用场景

```
1、热点数据的缓存
由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，我们可以设置过
期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。

2、限时业务的运用
redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信
息、手机验证码等业务场景。

3、计数器相关问题
redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在
比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

4、分布式锁
这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回
0。结合过期时间主要是防止死锁的出现。

5、队列
由于redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。
```

### 103 Linux 常见命令

```
列出文件列表：ls
创建目录和移除目录：mkdir rmdir
用于显示文件后几行内容：tail，例如： tail -n 1000：显示最后1000行  
打包：       tar -xvf
打包并压缩：  tar -zcvf
查找字符串：  grep
显示当前所在目录：pwd
创建空文件：touch
编辑器：vim
```

### 104  分布式事务处理方案

1 两阶段提交

```
将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase）,2是指两个阶段，p是指准备阶
段，C是指提交阶段

准备阶段：
事务管理器给每个参与都发送Prepared消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，此时事务没有
提交。

提交阶段：
如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚（Rollback）消息；否则，发送提交
（Commit）消息;参与者事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。
```

2 TCC解决方案

```
TCC 方案
TCC 的全称是：Try、Confirm、Cancel。

Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。
Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。
Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操
作。（把那些执行成功的回滚）
这种方案说实话几乎很少人使用，我们用的也比较少，但是也有使用的场景。因为这个事务回滚实际上是严重依赖于你自己写代
码来回滚和补偿了，会造成补偿代码巨大，非常之恶心。
```

3 本地消息解决方案（最大努力通知思想)

```
消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数
据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。

消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，
那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。

生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。
```

### 104  Get 和 Post 请求有哪些区别？ 

```
(1) get多用于从服务器请求获取数据，post多用于向服务器发送数据。
(2) get传递数据直接拼接在URL后面，在URL中可以看到。post方式在URL中是看不到参数的用
(3) get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。
```

### 105 说说TCP三次握手和四次挥手的全过程

三次握手

```
第一次握手:客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；;
第二次握手:服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时
服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入
ESTABLISHED状态，完成三次握手。 
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，
在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。
```

四次挥手

```
与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 
第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经
不会再给你发数据了。但是，此时主动关闭方还可以接受数据。 
第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序
号）。 
第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发
送完了，不会再给你发数据了。 
第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。
```

### 106 MySQL数据库分页查询的问题

写法1: 分页的深度越深,查询速度越慢

```
select * from user where create time>'2022-07-03’ limit 0,10;

select * from user where create time>'2022-07-03’ limit 100000,10;
```

写法2: 子查询的写法 速度会快一些。因为子查询中使用了覆盖索引。

```
select * from user where id in
	(select id from userwherecreate_time>'2022-07-03' limit 100000,10);
```

写法3: 内连接方式

```
select * from user inner join
            (select id from user 
                    where create time>'2022-07-03’ limit 100000,10) as t on user.id=t.id;
```

写法4: 使用分页游标

```
首先查询第一页
select * from user where create time>'2022-07-03’ and id>0 limit 10;

然后查询第二页，把第一页的查询结果放到第二页查询条件中.
select * from user where create time>'2022-07-03’ and id>10 limit 10:

分析:
and id>上一页的最大的id  limit 多少条记录
```

### 107 缓存和数据库的一致性问题

一 先更新缓存，后更新数据库（不推荐）

操作失败的情况

```
如果缓存更新成功，数据库更新失败，此时用户读取数据，仍然是从缓存中读取，读到的是数据最新值；但是过了一段时间缓存
失效后，此时再读取数据就需要从数据库中读取，而之前数据库更新失败所以存的仍是旧值，并且重新写到缓存中也是旧值。这
就导致用户发现自己修改的数据又变回去了，无疑会对业务造成影响！
```

高并发的情况

```
假设现在有线程A和线程B同时要进行更新操作，那么可能会这样：
（1）线程A更新了缓存
（2）线程B更新了缓存
（3）线程B更新了数据库
（4）线程A更新了数据库
由于无法保证更新数据库和更新缓存的顺序，所以就会导致数据库中脏数据的产生
```

二 先更新数据库，后更新缓存（不推荐）

操作失败的情况

```
如果数据库更新成功，缓存更新失败，那么此时数据库中是「新值」，缓存中是「旧值」。之后的请求仍然会先读取缓存获得
「旧值」，缓存失效后再读取数据库的「新值」。这就导致用户刚修改的数据却看不到变更，过一段时间才能看到，同样会对业
务造成影响
```

高并发的情况

```
假设现在有线程A和线程B同时要进行更新操作，那么可能会这样
线程A更新了据库
线程B更新了数据库
线程B更新了缓存 
线程A更新了缓存
由于无法保证更新数据库和更新缓存的顺序，所以就会导致缓存中脏数据的产生
```

三 先删除缓存，后更新数据库

操作失败的情况

```
如果缓存删除成功，数据库更新失败。用户读取数据时，缓存中为空，只能去数据库读取数据。但由于数据库更新失败，所以用
户读取到的是旧的数据。
```

高并发的情况

```
假设同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么可能会这样:
请求A进行写操作，删除缓存；
请求B查询发现缓存不存在；
请求B去数据库查询得到旧值；
请求B将旧值写入缓存；
请求A将新值写入数据库；
```

四 先更新数据库，后删除缓存（推荐）

操作失败的情况

```
如果数据库更新成功，缓存删除失败。用户读取数据时会先从缓存中读取，而缓存中存储的是旧的数据。如果缓存中的数据没有
失效时间，用户就会一直读取旧的数据！
```

高并发的情况

```
一个请求A做查询操作，一个请求B做更新操作。缓存刚好失效；
请求A查询数据库，得一个旧值；
请求B将新值写入数据库；
请求B删除缓存；
请求A将查到的旧值写入缓存；
```

使用Canal监听数据库的变化,更新缓存中的数据。

注意点:

```
并不是所有的接口都加缓存,实时的数据不要加缓存。
并不是所有的缓存都要保证和数据库中的数据要一致。(接口并不是高并发的接口)
更新数据,先更新数据在删除缓存中。
缓存最好添加一个过期时间。
```

### 108 ThreadLocal      Thread      ThreadLocalMap之间的关系？

```
每个Thread对象都持有一个ThreadLocalMap对象, 每个ThreadLocalMap对象中包含一个key 
value对, key是 ThreadLocal value是保存的值。一个线程中可以包含多个ThreadLocal。 可以根
据当前的 ThreadLocal获得当前线程中的值。
```

### 109   栈封闭

```
在方法里新建的局部变量,实际上是存储在每个线程私有的栈空间,而每个栈空间是不能被其他线程所访问到的,所以不会有线程
安全问题。这就是"栈封闭"技术。
```

### 110  JDK1.7 与JDK1.8  CurrentHashMap的数据结构

```
JDK1.8 CurrentHashMap的数据结构是: 数组  +  链表 +  红黑树。

JDK1.7 CurrentHashMap的数据结构是: 最外层是多个segment，每个segment的底层数据结构与HashMap类似，仍然是数组和
链表组成。每个segment都继承ReentrantLock锁，每个segment之间互不影响，提高了并发效率。
```

### 111  JDK1.7 与 JDK1.8  CurrentHashMap的对比

```
1 数据结构不同
  	1.7中ConcurrentHashMap使用的是Segment。1.8中ConcurrentHashMap使用的是数组+链表+红黑树
  	
2 Hash碰撞
	1.7中ConcurrentHashMap中元素的hash值相同,使用拉链法,将相同key的hash值放到同一个链表中。JDK1.8中
ConcurrentHashMap元素的函数值相同,先使用拉链法,如果链表太长就转为红黑树。

3 保证并发安全的角度
	1.7中使用Segment保证并发安全。Segment继承自ReentrantLock。1.8中使用CAS和Synchronzied关键字
```

### 112  CurrentHashMap添加元素的过程

```
(1) 判断key和value是否为null,如果key或者value为null 直接抛出异常
(2) 如果不为空根据key获得hash值
(3) 判断HashMap中的数组是否为空,如果为空则进行初始化。
(4) 如果数组已经被初始化,则通过数组长度-1与新增元素的kye的hash值进行位运算，得到数组的下标,通过下标获得该下标
对应的数组元素。判断数组该位置上是否有元素,如果没有直接放到数组的该位置上(使用的是CAS操作)。
(5) 如果数组该位置上有值,判断当前是否正在扩容,如果正在扩容,帮助其扩容
(6) 否则将该位置上锁,接着遍历该位置的链表,如果链表中不包含要插入的键值对节点时,则该节点放在链表的最后。如果要
插入的键值对存在,则用新的值替换老的值。
(7) 如果不是链表则进行红黑树的操作,将值放入到红黑树中。
(8) 如果链表长度大于阈值(8) 数组长度超过64,则进行树化(将链表转为红黑树)。
```

### 113  ArrayList集合扩容的规则

```
(1)在创建ArrayList时，可以指定初始容量。如果没有指定初始容量，则默认为10。
(2)当ArrayList的当前容量不足以容纳新元素时,会触发扩容操作。扩容时，ArrayList会创建一个新的更大的数组，并将原始
数组中的元素复制到新数组中。ArrayList的容量会以1.5倍增长。
(3)扩容操作涉及创建新数组、复制元素等操作，因此会有一定的开销。建议在添加大量元素时，事先估计所需容量，通过构造
函数指定初始容量，以减少扩容次数，提高性能。
```

### 114  ArrayList   LinkedList    Vector的区别

```
(1) ArrayList,LinkedList和Vector都继承自List接口。
(2) ArrayList和Vector的底层是动态数组，LinkedList的底层是双向链表。
(3) ArrayList和Vector的区别ArrayList是线程不安全的,Vector是线程安全的,Vector中的方法都是同步方法所以
ArrayList的执行效率要高于Vector。
(4) ArrayList和LinkedList的区别,ArrayList底层是数组,所以查找元素的速度比较快。LinkedList底层是链表新增和删除
元素的速度比较快。
```

### 115 Java内存模型

```
(1) Java内存模型分为主内存和工作内存。
(2) 主内存是所有线程共享的内存区域，其中存储了所有的变量和对象实例。
(3) 工作内存是每个线程私有的内存区域，其中存储了该线程正在使用的变量和对象实例的副本。
(4) 当一个线程访问某个变量或对象实例时，它首先需要将该变量或对象实例从主内存中读取到自己的工作内存中，并在工作
内存中进行操作。操作完成后，再将结果写回主内存中，以确保其他线程可以看到最新的结果。
(5) 每个线程不能直接访问其他线程的工作内存，只能通过主内存来间接交换信息。在多线程程序中，由于每个线程都有自己
的工作内存，因此可能存在工作内存之间的数据不一致问题。
```

### 116 JVM类加载器有哪些 

Bootstrap ClassLoader(启动类加载器)

```
负责加载安装在Java目录下的核心类。在Java安装目录下，就有一个“lib”目录，这里就有Java最核心的一些类库，支撑Java
系统的运行。所以一旦JVM启动，那么首先就会依托启动类加载器，去加载Java安装目录下的“lib”目录中的核心类库。
```

Extenssion ClassLoader(扩展类加载器)

```
在Java安装目录下有一个"lib/ext"目录,该目录下有一些类，需要使用Extenssion ClassLoader类加载器来加载该目录下的
类,支撑系统的运行。
```

Application ClassLoader(应用程序类加载器)

```
这类加载器就负责去加载“ClassPath”环境变量所指定的路径中的类（这个类加载器就负责加载你写好的那些类到内存里）
```

### 117 什么时候会触发类的加载和初始化

```
1 调用构造方法初始化类的实例,会加载和初始化该类。
2 初始化某个类之前,发现该类的父类还没有加载和初始化,会先加载这个类的父类,进行初始化操作。
3 包含"main()"方法的主类,必须立马加载和初始化。
```

### 118 CAP理论

```
一致性（C：Consistency）
一致性意思就是写操作之后进行读操作无论在哪个节点都需要返回写操作的值。

可用性（A：Availability）
指系统提供的服务一直处于可用的状态，每次请求都能获取到非错的响应（不保证获取的数据为最新数据）。在可用性条件
下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。

分区容错性（P：Partition Tolerance）
在分区容错性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个
网络环境都发生了故障。其实在分布式系统中，分区容错性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实
际上是要在可用性和一致性之间做权衡。

为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性。
为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。
```

### 119 Spring   SpringBoot  SpringCloud之间的关系

```
SpringBoot专注于快速方便的开发单个个体微服务。

SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服
务之间提供，配置管理、服务发现、熔断降级 限流、分布式事务等服务。SpringBoot可以离开SpringCloud独立使用开发项
目， 但是SpringCloud离不开SpringBoot。

SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。

Spring 最初最核心的两大核心功能 Spring Ioc 和 Spring Aop 成就了 Spring，Spring 在这两大核心的功能上不断的
发展，才有了 Spring 事务、Spring Mvc 等一系列伟大的产品，最终成就了 Spring 帝国，到了后期 Spring 几乎可以解
决企业开发中的所有问题。
```

### 120 如何保证接口幂等性

```
接口的幂等性实际上就是接口可重复调用，在调用方多次调用的情况下，接口最终得到的结果是一致的 。

解决方案:
1 在插入数据的时候，插入去重表，利用数据库的唯一索引特性，保证唯一的逻辑。
2 采用token加redis,数据提交前要向服务器申请token,token放到redis,设置token有效时间。用户提交请求时携带token, 
判断Redis中是否有此token。如果token存在redis中，直接删除token，然后继续处理业务请求。如果token不存在redis
中，说明token已过期或者当前业务已经执行过了，那么就不在往下处理业务逻辑。
3 乐观锁
```

### 121 Zookeeper实现分布式锁

```
多个请求从Zookeeper中获得锁,首先判断Zookeeper有没有锁的根节点,如果没有 则创建锁的根节点。然后每个请求都会在锁
的根节点下，一个接者一个的创建临时有序节点。如果当前请求创建的临时节点,是锁节点下的第一个子节点,那么当前请求可以
获得这把锁,第一个节点就会被删除。如果自己不是第一个节点，就对自己上一个节点加监听器。同时当前线程等待。 如果监听
到上一个节点被删除,创建当前节点的线程就会被唤醒,然后获得锁。

注意:(不要背诵,问到以后在回答即可)
如果某个客户端创建临时顺序节点之后，不小心自己宕机了也没关系，Zookeeper 感知到那个客户端宕机，会自动删除对应的
临时顺序节点，相当于自动释放锁，或者是自动取消自己的排队

```

### Redis实现分布式锁

### SpringBoot监控

### GateWay     Zuul 1.x    Zuul2.x区别

### 





