### 1  线程的创建方式有哪些?
```
创建线程只有一种方式就是构造Thread类,而实现线程的执行单元有两种方式。
方式一:实现Runnable接口的run方法,并把Runnable实例传递给Thread类。 
方式二:重写Thread类的run方法。
```
### 2 线程的状态有哪些? 
```
NEW:创建一个线程对象，还没有调用start()方法。
RUNNABLE：调用了start()方法，不管线程是否被CPU执行，都处于RUNNABLE。
BLOCKED: 线程等待获取对象的监视器锁时,处于BLOCKED状态时,此时线程无法被中断。
WAITING：线程处于无限等待状态，除非被其它线程唤醒或者接收到中断信号。
TIMED_WAITING：定时等待，线程等待指定时间后会恢复到RUNNABLE状态。可以提前被唤醒或者中断。
TERMINATED：线程执行完毕。
```
### 3  如何中断一个线程? 
```
interrupt通知线程要中断,不是强制。线程在执行完以后,才中断。
```
### 4 线程池中构造方法的参数有哪些?有什么作用? 
```
corePoolSize指的是核心线程数: 线程池在完成初始化后,默认情况下,线程池中并没有任何线程.线程池会等待有任务到来时,
再创建新线程去执行任务。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会
创建一个新线程来处理这个任务。
当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列中。如果队列也已满，则会去创
建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由
maxPoolSize指定。
一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指
定时间由keepAliveTime来设定。
工作队列有四种:
直接交接队列: 这种队列中不会保存任务。
无界队列: 这种队列中没有指定容量上限。
有界队列: 这种队列中有一个指定的容量。
延迟队列: 任务定时周期的延迟执行的队列。
```
### 5 sleep()方法和wait()方法有什么区别? 
```
sleep方法可以让线程进入休眠状态,不占用CPU资源,但是不释放锁,直到规定时间后再执行。休眠期间如果被中断,会抛出
异常并清除中断状态。sleep方法是线程中的方法。
wait方法可以让线程会进入阻塞阶段。wait方法会释放锁。wait方法是Object类中的方法。
```
### 6 关闭线程池的方法有哪些?他们有什么区别?
```
shutdown方法: 停止线程池,会将线程池中已经存在的任务执行完毕以后,再停止线程池。如果执行了shutdown方法以后,在向
线程池中添加任务,线程池会抛出拒绝的异常。
shutdownNow: 中断线程池中正在运行的任务,将任务队列中的任务返回。
```
### 7 volatile关键字的作用是什么?
```
可见性: 读一个volatile变量之前, 需要先使相应的本地缓存失效,这样就必须到主内存读取最新值, 写一个volatile属性
会立即刷入到主内存。

禁止指令重排序优化:解决单例双重锁乱序问题
```
### 8 线程中run方法和start方法的作用? 
```
start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当调用
run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。
```
### 9 ReentrantLock与synchronzied的区别？
``
(1)synchronized可用来修饰普通方法、静态方法和代码块，而ReentrantLock只能用在代码块上。
(2)synchronized会自动加锁和释放锁，当进入synchronized修饰的代码块之后会自动加锁，当离开synchronized的代
码段之后会自动释。而ReentrantLock需要手动加锁和释放锁
(3)synchronized属于非公平锁，而ReentrantLock既可以是公平锁也可以是非公平锁。
(4)响应中断不同：ReentrantLock可以响应中断，解决死锁的问题，而synchronized不能响应中断。

### 10 synchronized关键字与volatile关键字
synchronized关键字

synchronized可以修饰普通方法，静态方法和代码块。
synchronized修饰一个方法或者一个代码块的时候，它能够保证在同一时刻最多只有一个线程执行该段代码。当一个线程试
图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。
synchronized可以保证线程的原子性。

```
 volatile 
```
volatile的性能比synchronized要高。volatile只能修饰变量。
一个变量加了volatile关键字，就会告诉编译器和JVM内存模型：这个变量是对所有线程共享的、可见的，每次jvm都会读取
最新写入的值并使其对所有线程可见。
volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性。
### 11 CAS的原理?CAS的缺点?
原理

compare and swap
CAS有三个操作数: 内存值V,预期值A,要修改的值B, 只有当预期值A与内存值V相同时,才将内存值修改为B,否则什么都
不做。最后返回现在的值。CAS最终利用CPU的特殊指令, 一个指令可以做多个事情。

缺点

(1) ABA问题
   假设原来a的值是5,线程3想将a的值修改为10,在线程3执行的过程中,还没有来及更新a的值。线程1先
将a的值修改为了7, 线程2将a的值修改为了5。线程C此时在去修改a的值, 发现现在a的值是5, 那么线程C就可
以修改a的值,将值改为10。但是此时能够修改数据应该是不合理的,因为线程C在修改a的值之前,已经有线程
修改了a的值。可以添加version版本号解决该问题。 
(2) 自旋时间过长