### 1.SQL语句调优
#### 1.连表查询优化
```
1.使用小表驱动大表。
    inner join自动选择小表作为驱动表。
    left join 将左边的表当作驱动表,应该将小表放到左边。
    right join将右边的表当作驱动表,应该将小表放到右边。
2.给连接字段添加索引
3.驱动表与被驱动表都通过索引进行条件的筛选查询
```
#### 2.组合索引的使用规则
```
1.等值匹配原则: where条件里的字段的名称和顺序与组合索引一摸一样
2.最左前缀原则: 使用like语句操作, 写成like"值%"
3.最左匹配原则: 根据组合索引的最左侧的部分字段来查
4.范围规则: 将范围查询的条件放到组合索引的最后
5.等值匹配+范围匹配: 组合索引的最左侧的多个字段进行等值匹配+范围规则
```
#### 3.MySQL深度分页问题
```
1.首先给查询条件添加索引,
2.接着使用此索引查询, 得到主键id. (此时查询直接使用的是覆盖索引, 不需要回表)
3.然后将查出来的数据作为临时表, 连接原表, 对查询出来的结果进行数据回表.
```
#### 4.索引的其他使用的规则
```
1.表中的索引不能太多. 一般情况下2~3个组合索引, 配合1~2个单字段索引进行查询
2.保证主键是有序的(否则数据库需要页分裂)
3.根据where条件,order by条件,group by条件创建组合索引. 如果创建的组合索引覆盖不了这三个条件, 尽量让where条件的字段使用索引
4.如果字段的取值比较少, 可以不用索引
5.不要在索引上进行计算, 不要在索引使用函数
6.使用覆盖索引: 需要查询的字段值直接在索引树里就能取出来, 不需要回表到聚簇索引查询
7.尽量避免select *
8.索引不要包含null值
9.force Index: sql语句不按照添加的索引执行, 可以使用force index强制执行
```
#### 5.使用Explain关键字查看SQL语句的执行计划,是否使用索引,是否全表扫描
```
需要关注的列:
id             查询编号
type           本次查询表连接的类型
possible_keys  可能使用的索引
key            实际使用的索引
extra          额外信息
```
type列的取值性能从高到低顺序(system>const>eq_ref>ref>range>index>all)
```
system: 表中只有一条记录 查询条件主键或者唯一索引
const: 查询条件主键或者唯一索引
eq_ref: 通过主键连表查询
ref: 查询条件是非聚簇索引
range: 查询条件是一个范围
index: 查询的所有字段都是非聚簇索引的字段。
all: 全表扫描
```
extra显示的内容
```
using filesort: 排序时没有使用索引
using tempoary: 分组时没有使用索引
Using join buffer(Block Nested Loop): 链表查询时没有使用索引,使用的是块嵌套查询
```
### 2.ArrayList集合扩容的规则
```
1.在创建ArrayList时，可以指定初始容量。如果没有指定初始容量，则默认为10。
2.当ArrayList的当前容量不足以容纳新元素时,会触发扩容操作。扩容时，ArrayList会创建一个新的更
大的数组，并将原始数组中的元素复制到新数组中。ArrayList的容量会以1.5倍增长。
3.扩容操作涉及创建新数组、复制元素等操作，因此会有一定的开销。建议在添加大量元素时，事先估计所
需容量，通过构造函数指定初始容量，以减少扩容次数，提高性能。
```
### 3.ArrayList LinkedList Vector的区别
```
1.创建ArrayList,LinkedList和Vector都继承List接口
2.ArrayList和Vector的底层是动态数组, LinkedList的底层是双向链表
3.ArrayList和Vector的区别: ArrayList是线程不安全的, Vector是线程安全的, Vector中的方法都是同步方法,
所以ArrayList的执行效率要高于Vector
4.ArrayList和LinkedList的区别:ArrayList底层是数组, 所以查找元素的速度比较快,
LinkedList的底层是双向链表, 新增和删除元素的速度比较快
```
### 4.Java内存模型
```
1.Java内存模型分为主内存和工作内存。
2.主内存是所有线程共享的内存区域，其中存储了所有的变量和对象实例。
3.工作内存是每个线程私有的内存区域，其中存储了该线程正在使用的变量和对象实例的副本。
4.当一个线程访问某个变量或对象实例时，它首先需要将该变量或对象实例从主内存中读取到自己的工作内存中，并在工作内存中进行操作。
操作完成后，再将结果写回主内存中，以确保其他线程可以看到最新的结果。
5.每个线程不能直接访问其他线程的工作内存，只能通过主内存来间接交换信息。在多线程程序中，由于每
个线程都有自己的工作内存，因此可能存在工作内存之间的数据不一致问题。
```
### 5.介绍下MySQL连接算法
![简单嵌套循环](https://github.com/zhonger250/zhonger250.github.io/blob/main/%E9%9D%A2%E8%AF%95%E9%A2%98/picture/%E7%AE%80%E5%8D%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF.png)
```
Simple Nested-Loop Join（简单嵌套循环连接）(一句话: 被驱动表是全表扫描)
    1.驱动表A中拿取关联条件A1匹配被驱动表B所有列, 得到结果记录.
    2.继续A2,A3…直到驱动表A中所有关联条件匹配完.
    3.合并所有记录.
这种算法要对被驱动表B进行An次访问, 而且每次访问被驱动表B都是全表扫描. 性能非常差.
```
![索引嵌套循环](https://github.com/zhonger250/zhonger250.github.io/blob/main/%E9%9D%A2%E8%AF%95%E9%A2%98/picture/%E7%B4%A2%E5%BC%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF.png)
```
Index Nested-Loop Join (索引嵌套循环连接)(一句话: 被驱动表使用索引查询)
    1.从驱动表A中拿取关联条件A1匹配被驱动表B, 被驱动表B是基于索引查询(执行速度非常快,因为不用全表扫描),得到结果记录.
    2.继续A2,A3…直到驱动表A中所有关联条件匹配完.
    3.合并所有记录.
这种算法要对被驱动表B进行An次访问, 而被驱动表B每次基于索引查询是非常快的, 性能完全取决于驱动表A的关联条件条数。
```
![块嵌套循环](https://github.com/zhonger250/zhonger250.github.io/blob/main/%E9%9D%A2%E8%AF%95%E9%A2%98/picture/%E5%9D%97%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF.png)
```
Block Nested-Loop Join (块嵌套循环连接)
    在有索引的情况下，MySQL 会尝试去使用 Index Nested-Loop Join 算法，在有些情况下，可能
Join 的列就是没有索引，那么这时 MySQL 的选择绝对不会是最先介绍的 Simple Nested-Loop Join
算法，而是会优先使用Block Nested-Loop Join 的算法。（此句不要背诵自己看看就好）
    块嵌套循环对比简单嵌套循环多了一个中间处理的过程，也就是join buffer.
块嵌套循环将驱动表的查询JOIN相关列都给缓冲到JOIN BUFFER 当中，然后批量与非驱动表进行比较.
这样实现的话，可以将多次比较合并到一次，降低了非驱动表的访问频率。
```
