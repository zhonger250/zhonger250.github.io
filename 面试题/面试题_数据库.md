# 数据库

### 1.事务的特性(ACID):

#### 原子性(Atomicity):
```
事务中的所有操作要么全部执行，要么全都不执行。如果事务没有原子性的保证，那么在发生系统故障的情况下，数据库就有可能处于不一致状态。
```
#### 一致性(Consistency):
```
主要强调的是，如果在执行事务之前数据库是一致的，那么在执行事务之后数据库也还是一致的。
所谓一致性简单地说就是数据库中数据的完整性，包括它们的正确性。
```
#### 隔离性(Isolation):
```
即使多个事务并发（同时）执行，每个事务都感觉不到系统中有其他的事务在执行，因而也就能保证数据库的一致性。
```
#### 持久性(Durability):
```
事务成功执行后它对数据库的修改是永久的，即使系统出现故障也不受影响。
```
### 2.数据库的隔离级别有哪些？

#### 读未提交:
```
会产生：脏读、不可重复读、幻读等问题。
一个事务在执行过程中，可以看到其他事务没有提交的新增记录和更新的记录。
```
#### 读已提交:
```
会产生：不可重读、幻读等问题。
一个事务再执行过程中，可以看到其他事务已经提交的新增记录和更新的记录。
```
#### 可重复读:
```
会产生：幻读。
一个事务在执行过程中，不能看到其他事务已经提交的更新记录，但是可以看到其他事务已经提交的新增记录。
MySQL数据库的隔离级别是可重复读. 但是MySQL的可重复读不会产生幻读。
```
#### 串行化:
```
一个事务在执行过程中，完全看不到其他事务对数据库所作的更新。
当两个事务同时操作数据库时，如果第一个事务已经在访问该数据，第二个事务只能停下等待，必须等到一个事务结束之后才能恢复运行。
```
### 3.隔离级别产生的问题
#### 脏写：
```
1.事务A修改了值，但是没有提交。
2.之后事务B修改了该值。
3.事务A回滚，导致事务B修改的值也没了
```
#### 脏读：
```
1.事务A修改了值，但是没有提交。
2.之后事务B查询了该值。
3.事务A回滚，导致事务B再次查询就读不到之前“事务A修改的数据”
```
#### 不可重复读：
```
1.假设缓存页里一条数据值是A，
2.此时事务A开启之后，第一次查询这条数据，所以事务A读到的就是A值。
3.事务B将此数据修改成B，并且提交，事务A第二次查询数据，查到的值为B。
4.事务C将此数据修改成C，并且提交，事务A第三次查询数据，查到的值为C。
以上情况是否需要调整，需要依照程序具体的设定，“允许不可重复读”还是“允许重复读”。
```
#### 幻读：
```
幻读是指一个事务用一样的SQL语句多次查询，结果每次查询到了之前查询没有看到过的数据。
```
### 4.数据库设计的三大范式
#### 第一范式(确保每列保持原子性) :
```
保证每列保持原子性
数据库表中的所有字段值都是不可分解的原子值。
```
#### 第二范式:
```
数据库表中的每一列都和主键相关。
在一个数据库表中，一个表中只能保存一种数据，不能把多种数据保存在同一张数据库表中。
```
#### 第三范式:
```
数据库表中，每一列数据都和主键直接相关，不能间接相关。
```
### 5.MySQL存储引擎有哪些
#### MYISAM：
```
优势：较高的执行速度、占用空间相对较小。
劣势：不支持事务、不支持外键、并发性能差。
```
#### Innodb:
```
行级锁，提供了具有提交、回滚和崩溃恢复能力的事务安全，支持自动增长列，支持外键约束，并发能力强。
```
#### Memory:
```
特点：存储在内存中, 主要用于那些内容变化不频繁的代码表。
优势：默认使用Hash索引,检索效率非常高，速度快。
劣势：不适用于精确查找。数据在MySQL重启时会丢失。会占用和数据量成正比的内存空间。
```
### 6.什么是MVCC机制
```
1.MVCC
全称是多版本并发控制 (Multi-Version Concurrency Control)。
主要用到了Undo_Log链和ReadView数据结构。

2.undo_log
在数据修改之前会把数据拷贝一份到undo_log。
两个隐藏字段：
trx_id：表示最近一次更新这条数据的事务ID。
roll_pointer_id：指向更新这条数据之前生成的undo_log数据。

3.ReadView
隔离级别不同，创建次数不同：
读未提交: 每次执行查询的时候都会创建ReadView
读已提交: 仅在第一查询的时候生成ReadView, 后续复用此ReadView

四个字段：
m_ids:当前活跃的事务编号。
min_trx_id:最小活跃事务编号。
max_trx_id:预分配事务编号，当前最大事务编号+1。
creator_trx_id:ReadeView创建者的事务编号。
```
